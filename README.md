# Задача Nexign Bootcamp 2024

## Формулировка задания

### Дано:
Все звонки, совершенные абонентом сотового оператора, фиксируются в CDR файлы, которые собираются на коммутаторах. Когда абонент находится в роуминге за процесс сбора его данных отвечает обслуживающая сеть абонента. 
Для стандартизации данных между разными операторами международная ассоциация GSMA ввела стандарт BCE. Согласно ему, данные с CDR должны агрегировать в единый отчет UDR, который впоследствии передается оператору, обслуживающему абонента в домашней сети. 
На основе этого отчета, домашний оператор выставляет абоненту счет.

## Задачи:

### 1. Написать сервис, эмулирующий работу коммутатора, т.е. генерирующий CDR файлы
Условия: 
* 1 CDR = 1 месяц. Тарифицируемый период в рамках задания - 1 год;
* Данные в CDR идут не по порядку, т.е. записи по одному абоненту могут быть в разных частях файла;
* Количество и длительность звонков определяется случайным образом;
* Установленный список абонентов (не менее 10) хранится в локальной БД (h2);
* После генерации CDR, данные о транзакциях пользователя помещаются в соседнюю таблицу этой БД.
В рамках задания, CDR будут содержать записи следующего вида:
* Тип вызова (01 - исходящие, 02 - входящие);
* Номер абонента;
* Дата и время начала звонка (Unix time);
* Дата и время окончания звонка;
* Разделитель данных – запятая;
* Разделитель записей – перенос строки;
* Данные обязательно формируются в хронологическом порядке;

В рамках задания CDR может быть обычным txt;
Пример фрагмента CDR:
02,79876543221, 1709798657, 1709799601
01,79996667755, 1709899870, 1709905806
  
### 2. Написать сервис для обработки данных, полученных от CDR сервиса, и сбора их в UDR

Условия:
* Данные можно брать только из CDR файла. БД с описанием транзакций – тестовая, и доступа к ней, в рамках задания нет.
* Сгенерированные объекты отчета разместить в /reports.
* Шаблон имени: номер_месяц.json (79876543221_1.json);
* Класс генератора должен содержать методы:
a.       generateReport() – сохраняет все отчеты и выводит в консоль таблицу со всеми абонентами и итоговым временем звонков по всему тарифицируемому периоду каждого абонента;
b.       generateReport(msisdn) – сохраняет все отчеты и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в каждом месяце;
c.       generateReport(msisdn, month) – сохраняет отчет и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в указанном месяце.

## Описание решения

### Задача 1

Процедура generate сервиса CDRGenerationService генерирует 12 CDR файлов и заносит их данные в таблицу в локальной базе данных.
За начало периода тарификации берётся случайное значение времени в формате Unix time от *1514764800* до *1679443200* (*Mon Jan 01 2018 00:00:00 GMT+0000* и *Wed Mar 22 2023 00:00:00 GMT+0000* соответственно).
Первый файл генерируется именно с этим начальным значением. Начальные значения времени для других файлов увеличиваются на длинну месяца (30 дней) в секундах.

Используются два вспомогательных класса: 
1. В ConnectionUtil описана функция для установки соединения
2. В FileManger описаны процедуры и функции создания пустого файла .txt с нужным порядковым номером, а также получение пути до этого вайла

Процесс генерации одного файла:
1. Создаётся пустой .txt файл
2. Составляется список номеров, которые совершали вызовы
    * Из таблицы PNUMBERS локальной базы данных db выбирается случайный номер телефона абонента и добавляется в список. Эта операция повторяется столько раз, сколько должно быть записей
    * Количество записей определяется случайным образом
    * В таблице *PNUMBERS(ID INT PRIMARY KEY, NUMBER VARCHAR(15))* содержатся 25 номеров телефонов
    * Согласно заданию, номера известны заранее, поэтому при начале работы сервиса таблица должна быть заполнена
3. Для каждого номера генерируется строка, отвечающая шаблону фрагмента CDR
    * Тип вызова генерируется случайным образом
    * Время начала и завершения звонка генерируется случайным образом
    * На вход процедуры *generateFragment* подаются значения времени начала и конца месяца тарификации. В диапазоне между этими значениями выбирается время начала звонка
    * К времени начала звонка прибавляется случайное число от 30 до 3600 секунд (реальное возможное время звонка). Получаем время завершения звонка  
4. Каждая строка отдельно записывается в файл
5. При создании файла все соединения с базой данных открываются и закрываются по необходимости
   
После создания всех 12 файлов, их содержимое записывается таблицу *CDR(ID INT PRIMARY KEY, TYPE VARCHAR(2), NUMBER VARCHAR(15), TIMEOFSTART VARCHAR(255), TIMEOFEND VARCHAR(255))*:
1. Перед началом записи таблица CDR удаляется и создаётся новая. Используется процедура *resetCDRTable*. Это необходимо для того, чтобы избежать повторений уникального значения ID
2. Создаётся пакет, в который добавляются запросы на добавления строки файла в таблицу
3. После обработки всех файлов пакет запросов обрабатывается. Если возникает ошибка, то база данных возвращается к исходному состоянию
4. Соединение с базой данных открыто на протяжении всего процесса обработки

### Задача 2

Используются следующие вспомогательные классы:
1. В FileManger описаны методы создания пустого файла .json с нужным именем, а также получение пути до этого вайла
2. В Printer описаны методы для вывода отчётов в консоль
3. В Call описан звонок. Он имеет единственное поле *String totalTime* формата "hh:mm:ss" значение по умолчанию - "00:00:00". В классе описаны следующие процедуры и функции:
   * Функция получения итогового времени *getTotalTime*
   * Функция получения итогового времени в целочисленном формате *getTotalTimeAsInt*
   * Процедура прибавления разницы времени к итоговому времени *addTime*
4. В Subscriber описан абонент. Имеет поля *String msisdn* - номер абонента, *Call incomingCall* - входящий звонок, *Call outcomingCall*. В классе описаны следующие процедуры и функции:
   * Конструктор - создание нового объекта с заданным значением номера мобильного абонента
   * Геттеры для получения полей
   * Функция получения данных об абоненте в формате строки toString. В строке перечисляются три аргумента: номер абонента, общая длительность исходящего и входящего вызовов через запятую.
   
Рассмотрим все варианты входных данных процедуры generateReport сервиса UDRGenerationService:
- generateReport() – сохраняет все отчеты и выводит в консоль таблицу со всеми абонентами и итоговым временем звонков по всему тарифицируемому периоду каждого абонента
- generateReport(msisdn) – сохраняет все отчеты и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в каждом месяце
- generateReport(msisdn, month) – сохраняет отчет и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в указанном месяце
  
Предполагается, что перед началом работы сервиса были сгенерированы CDR файлы. Если же они созданы не были, то будет выведена ошибка.
Рассмотрим способ работы каждого варианта по отдельности:
### *generateReport()*
1. Читаются и обрабатываются 12 CDR файлов (CDRGenerationService генерирует файлы за весь период тарификации, их не может быть ни больше, ни меньше 12). (см. обработка словаря)
2. На основе полученных данных, каждый абонент из словаря при помощи *Gson* переводится в формат json и зависывается в пустой файл .json формата "номер.json"
3. Одновременно с записью в файлы, данные отчёта выводятся в консоль при помощи *Printer*
4. Словарь абонентов очищается

### *generateReport(msisdn)*
Для каждого из 12 месяцев перидо тарификации:
1. Читается и обрабатывается файл (см. обработка словаря)
2. Если за этот месяц существуют записи об абоненте, то создаётся файл отчёта за месяц
3. Если записи отсутствуют, то файл не создаётся, а в таблицу в консоли выводится сообщение о том, что ни одного вызова совершено не было

### *generateReport(msisdn, month)*
Процесс тот же, что и в пункту выше, но только для заданного месяца

### Обработка файла заключается в том следующем:
  - CDR файл читается построчно
  - На основе данных из каждой строки создаётся новый абонент и записывается в словарь с абонентами. Ключом является номер телефона абонента
  - Если абонент уже находится в словаре, то к его общему времени звонка (входящего или исходящего) добавляется длительность звонка из записи
  - Словарь используется для ускорения поиска сужествующих абонентовОбработка файла заключается в том следующем:
  - CDR файл читается построчно
  - На основе данных из каждой строки создаётся новый абонент и записывается в словарь с абонентами. Ключом является номер телефона абонента
  - Если абонент уже находится в словаре, то к его общему времени звонка (входящего или исходящего) добавляется длительность звонка из записи
  - Словарь используется для ускорения поиска сужествующих абонентов

### Тестирование
Для значимых классов были написаны Unit-тесты. Написание подробных тестов осложняется тем, что работа обоих сервисов завязана на случайных данных.
Все существующие тесты завершаются успешно.

## Дополнительно

### .jar файл
При запуске генерирует CDR файлы, а также отчёты UDR.
- По умолчанию срабатывает метод *generateReport()*
- Если предать только номер абонента, то срабатывает *generateReport(msisdn)*
- Если передать и номер абонента, и номер месяца, то срабатывает *generateReport(msisdn, month)*
- Аргумменты должны идти строго в указаном порядке, иначе выводится ошибка
- При передаче неправильных аргументов, то выводится ошибка

### Хранение файлов
* Все CDR файлы сохраняются в папку ~/resourses/CDRs/
* Все UDR файлы сохраняются в папку ~/resourses/reports/
* База данных хранится в папке db
* .jar файл с зависимостями хранится в папке ~/out/artifacts/nexignTask_jar/


